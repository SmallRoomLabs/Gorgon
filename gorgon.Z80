;*****************************************************************************
; Gorgon - A Defender-like game based on the 1981 Apple ][ game Gorgon
;
; Copyright 2017 Mats Engstrom, SmallRoomLabs. Licensed under the MIT license
;*****************************************************************************

;
; Define standard ROM routines
;
CLRSCR	EQU 3503 	; $0D6B
OPENCHN	EQU $1601 	;5633
print	EQU $203C
SETBRDR	EQU $229B 	;8859 Routine to set border color with A
LASTK	EQU $5C08 	;23560 Location holding the last pressed key
DF_SZ	EQU 23659
DF_CC	EQU 23684 	; Address of next character location for print
SLOWRAM	EQU $5DC0 	;24000 First usable location in slow ram
FASTRAM	EQU $8000 	;32768 Start of the faster upper 32K ram

BLACK	EQU 0
BLUE	EQU 1
RED	EQU 2
MAGENTA	EQU 3
GREEN	EQU 4
CYAN	EQU 5
YELLOW	EQU 6
WHITE	EQU 7

LASTLINE	EQU 191
GROUNDHEIGHT	EQU 16
SCOREHEIGHT	EQU 9
GROUNDSTART	EQU LASTLINE-SCOREHEIGHT-GROUNDHEIGHT
NEXTGROUNDLINEOFFSET EQU 32*5

;
;
;
DRAWSHIP MACRO
	ld	A,(BC)
	ld	(HL),A
	inc	HL
	inc	BC
	ld	A,(BC)
	ld	(HL),A
	inc	HL
	inc	BC
	ld	A,(BC)
	ld	(HL),A
	inc	HL
	inc	BC
	ld	A,(BC)
	ld	(HL),A
	inc	HL
	inc	BC
ENDM

;
;
;
MACRO DRAW1GROUNDLINEAT,myRow
	ld	DE,myRow
	ld	BC,32
	ldir
	ld	BC,NEXTGROUNDLINEOFFSET
	add	HL,BC
ENDM

	ORG $6000

	include "align.Z80"
	include "ytable.Z80"
	include "grounddata.Z80"
	include "shipdata.Z80"
	include "fatfont.Z80"
	include "score.Z80"


Footer:
	DB 22,1,0,'SCRE: ..... HISC:..... FUEL:....'
Footer_: EQU $

xpos	DW	256
speed	DW	$FFFF

Box1	DB $00,$00,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$00,$00,$00,$00,$FF,$FF,$FF,$FF,$00,$00
Box2	DB $00,$00,$80,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$01,$00,$00,$00,$00,$80,$00,$00,$01,$00,$00


Start:
	ld	A,BLACK
	call	SETBRDR

	ld	A,RED<<8+WHITE
	ld	(23693),A 	; Set screen colours.

	call	CLRSCR 		; clear the screen.

	ld	A,253
	call	OPENCHN

	ld	DE,Footer 	; address of string
	ld	BC,Footer_ - Footer ; length of string to print
	call	8252 		; print our string

	call	ResetScores

	ld	DE,Row0		; Draw boxes for screen overview & lives
	ld	HL,Box1
	ld	BC,32
	ldir

	ld	DE,Row1
	ld	HL,Box2
	ld	BC,32
	ldir

	ld	DE,Row25
	ld	HL,Box2
	ld	BC,32
	ldir

	ld	DE,Row26
	ld	HL,Box1
	ld	BC,32
	ldir


Loop:

	ld	BC,shipR4
	ld	HL,Row2+26
	DRAWSHIP
	ld	HL,Row3+26
	DRAWSHIP
	ld	HL,Row4+26
	DRAWSHIP
	ld	HL,Row5+26
	DRAWSHIP
	ld	HL,Row6+26
	DRAWSHIP
	ld	HL,Row7+26
	DRAWSHIP

	ld	BC,shipR4
	ld	HL,Row10+26
	DRAWSHIP
	ld	HL,Row11+26
	DRAWSHIP
	ld	HL,Row12+26
	DRAWSHIP
	ld	HL,Row13+26
	DRAWSHIP
	ld	HL,Row14+26
	DRAWSHIP
	ld	HL,Row15+26
	DRAWSHIP

	ld	BC,shipR4
	ld	HL,Row18+26
	DRAWSHIP
	ld	HL,Row19+26
	DRAWSHIP
	ld	HL,Row20+26
	DRAWSHIP
	ld	HL,Row21+26
	DRAWSHIP
	ld	HL,Row22+26
	DRAWSHIP
	ld	HL,Row23+26
	DRAWSHIP


	call	ScoreDisplayer

	ld	BC,(xpos)
	ld	A,C
	and	%00000011
	srl	B		; The lower two bits is used to select one of
	rr	C		; four different pre-shifted ground images so
	srl	B		; we need to shift BC right by two bits (/4)
	rr	C		; to use for the bytes offset into the ground

	cp	0		; Select the right pre-shifted ground table
	jp	NZ,gofs1	; according to A (the two LSB of xpos)
	ld	HL,Ground0ofs0
gofs1	cp	1
	jp	NZ,gofs2
	ld	HL,Ground0ofs1
gofs2	cp	2
	jp	NZ,gofs3
	ld	HL,Ground0ofs2
gofs3	cp	3
	jp	NZ,gofs4
	ld	HL,Ground0ofs3
gofs4

	add	HL,BC		; Add byte-offset to the address of the
				; selected ground table

	; ld	DE,Row166
	; ld	BC,32
	; ldir

	DRAW1GROUNDLINEAT Row166
	DRAW1GROUNDLINEAT Row167
	DRAW1GROUNDLINEAT Row168
	DRAW1GROUNDLINEAT Row169
	DRAW1GROUNDLINEAT Row170
	DRAW1GROUNDLINEAT Row171
	DRAW1GROUNDLINEAT Row172
	DRAW1GROUNDLINEAT Row173
	DRAW1GROUNDLINEAT Row174
	DRAW1GROUNDLINEAT Row175
	DRAW1GROUNDLINEAT Row176
	DRAW1GROUNDLINEAT Row177
	DRAW1GROUNDLINEAT Row178
	DRAW1GROUNDLINEAT Row179

	ld	BC,(speed)		; Update scroll location of ground
	ld	HL,(xpos)		; according to speed
	add	HL,BC

	ld	A,H			; Did we pass the left edge?
	cp	$FF
	jp	Z,acrossLeftEdge	; Yes, then fixup xpos

	ld	BC,5*128		; Did we pass the right edge?
	or 	A
	sbc 	HL,BC
	add 	HL,BC
	jp	C,doneScrolling		; Nope - we're done here

acrossRightEdge:
	ld	BC,5*128		; Passed by the right edge, so backup
	or	A			; so we can continue scrolling
	sbc	HL,BC
	jp	doneScrolling

acrossLeftEdge:
 	ld	BC,128*5		; We're negative, so jump forward to
	add	HL,BC			; the end so we can continue

doneScrolling:
	ld	(xpos),HL		; Set xpos to the updated location


	ld	A,BLACK
	call	SETBRDR
	halt
	ld	A,GREEN
	call	SETBRDR
	jp	Loop

JallaBye:
	halt
	call	WaitForKey
	ret

;
; Displays a number 0..9 from A
;
DispNum:
	add	A,A 		; Multiply A by 8
	add	A,A
	add	A,A
	ld	DE,FATFONT+$10*8 ; Address of digit 0 in charmap
	add	A,E		; Add A*8 to the address to get to the
	ld	E,A 		; correct offset of the requred digit

	ld	B,8
dn0	ld	A,(DE)		; Copy all 8 rows of the character map
	inc	DE		; into to the screen memory
	ld	(HL),A
	inc	H
	djnz	dn0
	ret

;
;
;
WaitForKey:
	ld	hl,LASTK	; LAST K system variable.
	ld	(hl),0		; put null value there.
wfk0	ld	a,(hl)		; new value of LAST K.
	cp	0		; is it still zero?
	jr	z,wfk0		; yes, so no key pressed.
	ret			; key was pressed.



	 END Start
